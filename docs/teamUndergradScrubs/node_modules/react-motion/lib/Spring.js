'use strict';

exports.__esModule = true;
exports.updateCurrVals = updateCurrVals;
exports.updateCurrV = updateCurrV;
exports.noSpeed = noSpeed;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _utils = require('./utils');

var _stepper = require('./stepper');

var _stepper2 = _interopRequireDefault(_stepper);

var FRAME_RATE = 1 / 60;

function zero() {
  return 0;
}

// TODO: test
function mergeDiff(_x, _x2, _x3, _x4) {
  var _again = true;

  _function: while (_again) {
    var collA = _x,
        collB = _x2,
        onRemove = _x3,
        accum = _x4;
    a = aa = b = bb = undefined;
    _again = false;
    var a = collA[0];
    var aa = collA.slice(1);
    var b = collB[0];
    var bb = collB.slice(1);

    if (collA.length === 0 && collB.length === 0) {
      return accum;
    }
    if (collA.length === 0) {
      return accum.concat(collB);
    }
    if (collB.length === 0) {
      if (onRemove(a)) {
        _x = aa;
        _x2 = collB;
        _x3 = onRemove;
        _x4 = accum;
        _again = true;
        continue _function;
      }
      _x = aa;
      _x2 = collB;
      _x3 = onRemove;
      _x4 = accum.concat(a);
      _again = true;
      continue _function;
    }
    if (a === b) {
      // fails for ([undefined], [], () => true). but don't do that
      _x = aa;
      _x2 = bb;
      _x3 = onRemove;
      _x4 = accum.concat(a);
      _again = true;
      continue _function;
    }
    if (collB.indexOf(a) === -1) {
      if (onRemove(a)) {
        _x = aa;
        _x2 = collB;
        _x3 = onRemove;
        _x4 = accum;
        _again = true;
        continue _function;
      }
      _x = aa;
      _x2 = collB;
      _x3 = onRemove;
      _x4 = accum.concat(a);
      _again = true;
      continue _function;
    }
    _x = aa;
    _x2 = collB;
    _x3 = onRemove;
    _x4 = accum;
    _again = true;
    continue _function;
  }
}

function mergeDiffObj(a, b, onRemove) {
  var keys = mergeDiff(Object.keys(a), Object.keys(b), function (_a) {
    return !onRemove(_a);
  }, []);
  var ret = {};
  keys.forEach(function (key) {
    if (b.hasOwnProperty(key)) {
      ret[key] = b[key];
    } else {
      ret[key] = onRemove(key);
    }
  });

  return ret;
}

// TODO: refactor common logic with updateCurrV

function updateCurrVals(frameRate, currVals, currV, endValue, k, b) {
  if (endValue === null) {
    return null;
  }
  if (typeof endValue === 'number') {
    if (k == null || b == null) {
      return endValue;
    }
    // TODO: do something to stepper to make this not allocate (2 steppers?)
    return _stepper2['default'](frameRate, currVals, currV, endValue, k, b)[0];
  }
  if (endValue.val != null && endValue.config && endValue.config.length === 0) {
    return endValue;
  }
  if (endValue.val != null) {
    var _ref = endValue.config || [170, 26];

    var _k = _ref[0];
    var _b = _ref[1];

    var ret = {
      val: updateCurrVals(frameRate, currVals.val, currV.val, endValue.val, _k, _b)
    };
    if (endValue.config) {
      ret.config = endValue.config;
    }
    return ret;
  }
  if (Array.isArray(endValue)) {
    return endValue.map(function (_, i) {
      return updateCurrVals(frameRate, currVals[i], currV[i], endValue[i], k, b);
    });
  }
  if (_utils.isPlainObject(endValue)) {
    var _ret = (function () {
      var ret = {};
      Object.keys(endValue).forEach(function (key) {
        ret[key] = updateCurrVals(frameRate, currVals[key], currV[key], endValue[key], k, b);
      });
      return {
        v: ret
      };
    })();

    if (typeof _ret === 'object') return _ret.v;
  }
  return endValue;
}

function updateCurrV(frameRate, currVals, currV, endValue, k, b) {
  if (endValue === null) {
    return null;
  }
  if (typeof endValue === 'number') {
    if (k == null || b == null) {
      return _utils.mapTree(zero, currV);
    }
    // TODO: do something to stepper to make this not allocate (2 steppers?)
    return _stepper2['default'](frameRate, currVals, currV, endValue, k, b)[1];
  }
  if (endValue.val != null && endValue.config && endValue.config.length === 0) {
    return _utils.mapTree(zero, currV);
  }
  if (endValue.val != null) {
    var _ref2 = endValue.config || [170, 26];

    var _k = _ref2[0];
    var _b = _ref2[1];

    var ret = {
      val: updateCurrV(frameRate, currVals.val, currV.val, endValue.val, _k, _b)
    };
    if (endValue.config) {
      ret.config = endValue.config;
    }
    return ret;
  }
  if (Array.isArray(endValue)) {
    return endValue.map(function (_, i) {
      return updateCurrV(frameRate, currVals[i], currV[i], endValue[i], k, b);
    });
  }
  if (_utils.isPlainObject(endValue)) {
    var _ret2 = (function () {
      var ret = {};
      Object.keys(endValue).forEach(function (key) {
        ret[key] = updateCurrV(frameRate, currVals[key], currV[key], endValue[key], k, b);
      });
      return {
        v: ret
      };
    })();

    if (typeof _ret2 === 'object') return _ret2.v;
  }
  return _utils.mapTree(zero, currV);
}

function noSpeed(coll) {
  if (Array.isArray(coll)) {
    return coll.every(noSpeed);
  }
  if (_utils.isPlainObject(coll)) {
    return Object.keys(coll).every(function (key) {
      return key === 'config' ? true : noSpeed(coll[key]);
    });
  }
  return typeof coll === 'number' ? coll === 0 : true;
}

var Spring = _react2['default'].createClass({
  displayName: 'Spring',

  propTypes: {
    endValue: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.object, _react.PropTypes.array]).isRequired,
    children: _react.PropTypes.func.isRequired
  },

  getInitialState: function getInitialState() {
    var endValue = this.props.endValue;

    if (typeof endValue === 'function') {
      endValue = endValue();
    }
    return {
      currVals: endValue,
      currV: _utils.mapTree(zero, endValue),
      now: null
    };
  },

  componentDidMount: function componentDidMount() {
    this.raf(true, false);
  },

  componentWillReceiveProps: function componentWillReceiveProps() {
    this.raf(true, false);
  },

  componentWillUnmount: function componentWillUnmount() {
    cancelAnimationFrame(this._rafID);
  },

  _rafID: null,

  raf: function raf(justStarted, isLastRaf) {
    var _this = this;

    if (justStarted && this._rafID != null) {
      // already rafing
      return;
    }
    this._rafID = requestAnimationFrame(function () {
      var _state = _this.state;
      var currVals = _state.currVals;
      var currV = _state.currV;
      var now = _state.now;
      var endValue = _this.props.endValue;

      if (typeof endValue === 'function') {
        endValue = endValue(currVals);
      }
      var frameRate = now && !justStarted ? (Date.now() - now) / 1000 : FRAME_RATE;

      var newCurrVals = updateCurrVals(frameRate, currVals, currV, endValue);
      var newCurrV = updateCurrV(frameRate, currVals, currV, endValue);

      _this.setState(function () {
        return {
          currVals: newCurrVals,
          currV: newCurrV,
          now: Date.now()
        };
      });

      var stop = noSpeed(newCurrV);
      if (stop && !justStarted) {
        // this flag is necessary, because in `endValue` callback, the user
        // might check that the current value has reached the destination, and
        // decide to return a new destination value. However, since s/he's
        // accessing the last tick's current value, and if we stop rafing after
        // speed is 0, the next `endValue` is never called and we never detect
        // the new chained animation. isLastRaf ensures that we raf a single
        // more time in case the user wants to chain another animation at the
        // end of this one
        if (isLastRaf) {
          _this._rafID = null;
        } else {
          _this.raf(false, true);
        }
      } else {
        _this.raf(false, false);
      }
    });
  },

  render: function render() {
    var currVals = this.state.currVals;

    return _react2['default'].Children.only(this.props.children(currVals));
  }
});

exports.Spring = Spring;
var TransitionSpring = _react2['default'].createClass({
  displayName: 'TransitionSpring',

  propTypes: {
    endValue: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.object]).isRequired,
    willLeave: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.object, _react.PropTypes.array]),
    willEnter: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.object, _react.PropTypes.array]),
    children: _react.PropTypes.func.isRequired
  },

  getDefaultProps: function getDefaultProps() {
    return {
      willEnter: function willEnter(key, value) {
        return value;
      },
      willLeave: function willLeave() {
        return null;
      }
    };
  },

  getInitialState: function getInitialState() {
    var endValue = this.props.endValue;

    if (typeof endValue === 'function') {
      endValue = endValue();
    }
    return {
      currVals: endValue,
      currV: _utils.mapTree(zero, endValue),
      now: null
    };
  },

  componentDidMount: function componentDidMount() {
    this.raf(true, false);
  },

  componentWillReceiveProps: function componentWillReceiveProps() {
    this.raf(true, false);
  },

  componentWillUnmount: function componentWillUnmount() {
    cancelAnimationFrame(this._rafID);
  },

  _rafID: null,

  raf: function raf(justStarted, isLastRaf) {
    var _this2 = this;

    if (justStarted && this._rafID != null) {
      // already rafing
      return;
    }
    this._rafID = requestAnimationFrame(function () {
      var _state2 = _this2.state;
      var currVals = _state2.currVals;
      var currV = _state2.currV;
      var now = _this2.state.now;
      var endValue = _this2.props.endValue;
      var _props = _this2.props;
      var willEnter = _props.willEnter;
      var willLeave = _props.willLeave;

      if (typeof endValue === 'function') {
        endValue = endValue(currVals);
      }

      var mergedVals = undefined;
      if (Array.isArray(endValue)) {
        (function () {
          var currValsObj = {};
          currVals.forEach(function (objWithKey) {
            currValsObj[objWithKey.key] = objWithKey;
          });

          var endValueObj = {};
          endValue.forEach(function (objWithKey) {
            endValueObj[objWithKey.key] = objWithKey;
          });
          var currVObj = {};
          endValue.forEach(function (objWithKey) {
            currVObj[objWithKey.key] = objWithKey;
          });

          var mergedValsObj = mergeDiffObj(currValsObj, endValueObj, function (key) {
            return willLeave(key, endValue, currVals, currV);
          });

          var mergedValsKeys = Object.keys(mergedValsObj);
          mergedVals = mergedValsKeys.map(function (key) {
            return mergedValsObj[key];
          });
          mergedValsKeys.filter(function (key) {
            return !currValsObj.hasOwnProperty(key);
          }).forEach(function (key) {
            currValsObj[key] = willEnter(key, mergedValsObj[key], endValue, currVals, currV);
            currVObj[key] = _utils.mapTree(zero, currValsObj[key]);
          });

          currVals = Object.keys(currValsObj).map(function (key) {
            return currValsObj[key];
          });
          currV = Object.keys(currVObj).map(function (key) {
            return currVObj[key];
          });
        })();
      } else {
        // only other option is obj
        mergedVals = mergeDiffObj(currVals, endValue,
        // TODO: stop allocating like crazy in this whole code path
        function (key) {
          return willLeave(key, endValue, currVals, currV);
        });

        // TODO: check if this is necessary
        currVals = _utils.clone(currVals);
        currV = _utils.clone(currV);
        Object.keys(mergedVals).filter(function (key) {
          return !currVals.hasOwnProperty(key);
        }).forEach(function (key) {
          // TODO: param format changed, check other demos
          currVals[key] = willEnter(key, mergedVals[key], endValue, currVals, currV);
          currV[key] = _utils.mapTree(zero, currVals[key]);
        });
      }

      var frameRate = now && !justStarted ? (Date.now() - now) / 1000 : FRAME_RATE;

      var newCurrVals = updateCurrVals(frameRate, currVals, currV, mergedVals);
      var newCurrV = updateCurrV(frameRate, currVals, currV, mergedVals);

      _this2.setState(function () {
        return {
          currVals: newCurrVals,
          currV: newCurrV,
          now: Date.now()
        };
      });

      var stop = noSpeed(newCurrV);
      if (stop && !justStarted) {
        if (isLastRaf) {
          _this2._rafID = null;
        } else {
          _this2.raf(false, true);
        }
      } else {
        _this2.raf(false, false);
      }
    });
  },

  render: function render() {
    var currVals = this.state.currVals;

    return _react2['default'].Children.only(this.props.children(currVals));
  }
});

exports.TransitionSpring = TransitionSpring;
function reorderKeys(obj, f) {
  var ret = {};
  f(Object.keys(obj)).forEach(function (key) {
    ret[key] = obj[key];
  });
  return ret;
}

var utils = {
  reorderKeys: reorderKeys
};
exports.utils = utils;

// coming soon
// PropTypes.arrayOf(PropTypes.shape({
//   key: PropTypes.any.isRequired,
// })),
// PropTypes.arrayOf(PropTypes.element),

// TODO: numbers? strings?