'use strict';

exports.__esModule = true;
exports.isPlainObject = isPlainObject;
exports.clone = clone;
exports.mapTree = mapTree;
exports.reinsert = reinsert;
exports.clamp = clamp;
exports.range = range;

function isPlainObject(obj) {
  return obj ? typeof obj === 'object' && Object.getPrototypeOf(obj) === Object.prototype : false;
}

// damn it JS

function clone(coll) {
  return JSON.parse(JSON.stringify(coll));
}

// export function eq(a, b) {
//   return JSON.stringify(a) === JSON.stringify(b);
// }

// currenly a helper used for producing a tree of the same shape as the
// input(s),  but with different values. It's technically not a real `map`
// equivalent for trees, since it skips calling f on non-numbers.

// TODO: probably doesn't need path, stop allocating uselessly
// TODO: don't need to map over many trees anymore
// TODO: skipping non-numbers is weird and non-generic. Use pre-order traversal
// assume trees are of the same shape
function _mapTree(path, f, trees) {
  var t1 = trees[0];
  if (typeof t1 === 'number') {
    return f.apply(undefined, [path].concat(trees));
  }
  if (Array.isArray(t1)) {
    return t1.map(function (_, i) {
      return _mapTree([].concat(path, [i]), f, trees.map(function (val) {
        return val[i];
      }));
    });
  }
  if (isPlainObject(t1)) {
    var _ret = (function () {
      var newTree = {};
      Object.keys(t1).forEach(function (key) {
        newTree[key] = _mapTree([].concat(path, [key]), f, trees.map(function (val) {
          return val[key];
        }));
      });
      return {
        v: newTree
      };
    })();

    if (typeof _ret === 'object') return _ret.v;
  }
  // return last one just because
  return trees[trees.length - 1];
}

function mapTree(f) {
  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  return _mapTree([], f, rest);
}

// function _reshapeTree(path, a, b, f) {
//   if (a == null) {
//     throw new Error('wtf2');
//   }

//   if (b == null) {
//     return f(path, a);
//   }

//   if (Array.isArray(a)) {
//     return a.map((val, i) => _reshapeTree([...path, i], val, b[i], f));
//   }
//   if (Object.prototype.toString.call(a) === '[object Object]') {
//     const newTree = {};
//     Object.keys(a).forEach(key => {
//       newTree[key] = _reshapeTree([...path, key], a[key], b[key], f);
//     });
//     return newTree;
//   }

//   return b;
// }

// export function reshapeTree(a, b, f) {
//   return _reshapeTree([], a, b, f);
// }

// export function toOj(vals, keys) {
//   const ret = {};
//   vals.forEach((val, i) => ret[keys[i]] = val);
//   return ret;
// }

// export function toArr(obj) {
//   const keys = Object.keys(obj);
//   const vals = keys.map(k => obj[k]);
//   return [keys, vals];
// }

// TODO: these are for a demos, not for the library. Move

function reinsert(arr, from, to) {
  var _arr = arr.slice(0);
  var val = _arr[from];
  _arr.splice(from, 1);
  _arr.splice(to, 0, val);
  return _arr;
}

function clamp(n, min, max) {
  return Math.max(Math.min(n, max), min);
}

function range(start, afterStop) {
  var _afterStop = afterStop;
  var _start = start;
  if (afterStop == null) {
    _afterStop = start;
    _start = 0;
  }
  var ret = [];
  for (var i = _start; i < _afterStop; i++) {
    ret.push(i);
  }
  return ret;
}